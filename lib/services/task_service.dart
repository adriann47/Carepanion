import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:softeng/data/profile_service.dart';

/// Task service for interacting with Supabase `tasks` table.
///
/// Expected table schema (SQL suggestion):
///
/// create table if not exists public.tasks (
///   id bigint generated by default as identity primary key,
///   user_id uuid null references auth.users(id) on delete set null,
///   title text not null,
///   description text,
///   category text,
///   due_date date not null,
///   start_at timestamptz,
///   end_at timestamptz,
///   status text default 'todo',
///   created_at timestamptz not null default now()
/// );
class TaskService {
  TaskService._();

  static final SupabaseClient _client = Supabase.instance.client;
  static String? get _uid => _client.auth.currentUser?.id;

  static String _toDateString(DateTime date) =>
      DateFormat('yyyy-MM-dd').format(date);

  static DateTime? _combineDateAndTime(DateTime date, TimeOfDay? tod) {
    if (tod == null) return null;
    return DateTime(date.year, date.month, date.day, tod.hour, tod.minute);
  }

  /// Creates a task row in Supabase.
  static Future<void> createTask({
    required String title,
    String? description,
    required DateTime dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
    String? forUserId,
  }) async {
    final startAt = _combineDateAndTime(dueDate, startTime)?.toUtc();
    final endAt = _combineDateAndTime(dueDate, endTime)?.toUtc();

    // Determine creator (guardian) and their display name
    final creatorId = _client.auth.currentUser?.id;
    String? creatorName;
    try {
      final prof = await ProfileService.fetchProfile(_client);
      final raw = (prof?['fullname'] as String?)?.trim();
      if (raw != null && raw.isNotEmpty) {
        creatorName = raw;
      } else {
        final email = _client.auth.currentUser?.email;
        if (email != null && email.isNotEmpty) {
          final local = email.split('@').first;
          final parts = local
              .split(RegExp(r'[._\s]+'))
              .where((s) => s.isNotEmpty)
              .map((p) => p[0].toUpperCase() + p.substring(1))
              .join(' ');
          creatorName = parts.isNotEmpty ? parts : email;
        }
      }
    } catch (_) {}

    final data = <String, dynamic>{
      'title': title,
      'description': description,
      'category': (category ?? '').trim().isEmpty ? null : category,
      'due_date': _toDateString(dueDate),
      'start_at': startAt?.toIso8601String(),
      'end_at': endAt?.toIso8601String(),
      'status': 'todo',
      'user_id': forUserId ?? _client.auth.currentUser?.id,
      if (creatorId != null) 'created_by': creatorId,
      if (creatorName != null && creatorName.trim().isNotEmpty)
        'created_by_name': creatorName.trim(),
    }..removeWhere((key, value) => value == null);

    try {
      await _client.from('tasks').insert(data);
    } catch (e) {
      final msg = e.toString().toLowerCase();
      // Fallback if optional columns don't exist in DB
      final fallback = Map<String, dynamic>.from(data);
      bool modified = false;
      if (msg.contains('created_by_name') &&
          fallback.containsKey('created_by_name')) {
        fallback.remove('created_by_name');
        modified = true;
      }
      if (msg.contains('created_by') && fallback.containsKey('created_by')) {
        fallback.remove('created_by');
        modified = true;
      }
      if (msg.contains("'category'") ||
          (msg.contains('category') && fallback.containsKey('category'))) {
        fallback.remove('category');
        modified = true;
      }
      if (modified) {
        await _client.from('tasks').insert(fallback);
        return;
      }
      rethrow;
    }
  }

  /// Fetch tasks for a specific calendar date (local date match on `due_date`).
  static Future<List<Map<String, dynamic>>> getTasksForDate(
    DateTime date, {
    String? forUserId,
  }) async {
    final dateStr = _toDateString(date);
    var builder = _client.from('tasks').select().eq('due_date', dateStr);

    final uid = _uid;
    if (forUserId != null) {
      builder = builder.eq('user_id', forUserId);
    } else if (uid != null) {
      builder = builder.eq('user_id', uid);
    }

    final result = await builder.order('start_at', ascending: true);
    return List<Map<String, dynamic>>.from(result);
  }

  /// Update an existing task.
  static Future<void> updateTask({
    required int id,
    String? title,
    String? description,
    DateTime? dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
    String? status,
    String? forUserId,
  }) async {
    final Map<String, dynamic> data = {};
    if (title != null) data['title'] = title;
    if (description != null) data['description'] = description;
    if (category != null)
      data['category'] = category.trim().isEmpty ? null : category;
    if (status != null) data['status'] = status;
    if (dueDate != null) data['due_date'] = _toDateString(dueDate);

    // We may need the existing due_date when only time changes
    DateTime? effectiveDate = dueDate;
    if (effectiveDate == null && (startTime != null || endTime != null)) {
      var builder = _client.from('tasks').select('due_date').eq('id', id);
      final uid2 = forUserId ?? _uid;
      if (uid2 != null) builder = builder.eq('user_id', uid2);
      final List existingList = await builder.limit(1);
      if (existingList.isNotEmpty) {
        final dueStr = existingList.first['due_date']?.toString();
        if (dueStr != null && dueStr.isNotEmpty) {
          try {
            effectiveDate = DateTime.parse(dueStr);
          } catch (_) {}
        }
      }
    }

    if (effectiveDate != null) {
      if (startTime != null) {
        final startAt = _combineDateAndTime(effectiveDate, startTime)?.toUtc();
        data['start_at'] = startAt?.toIso8601String();
      }
      if (endTime != null) {
        final endAt = _combineDateAndTime(effectiveDate, endTime)?.toUtc();
        data['end_at'] = endAt?.toIso8601String();
      }
    }

    // Remove nulls so we only update provided fields
    data.removeWhere((key, value) => value == null);

    if (data.isEmpty) return; // nothing to update

    try {
      var upd = _client.from('tasks').update(data).eq('id', id);
      final uid = forUserId ?? _uid;
      if (uid != null) {
        upd = upd.eq('user_id', uid);
      }
      final List updatedList = await upd.select('id');
      if (updatedList.isEmpty) {
        throw Exception(
          'Task not updated. It may not exist or you may not have permission.',
        );
      }
    } catch (e) {
      final msg = e.toString().toLowerCase();
      if (msg.contains("'category'") ||
          (msg.contains('category') && data.containsKey('category'))) {
        final fallback = Map<String, dynamic>.from(data);
        fallback.remove('category');
        var upd = _client.from('tasks').update(fallback).eq('id', id);
        final uid = forUserId ?? _uid;
        if (uid != null) {
          upd = upd.eq('user_id', uid);
        }
        final List updatedList = await upd.select('id');
        if (updatedList.isEmpty) {
          throw Exception(
            'Task not updated. It may not exist or you may not have permission.',
          );
        }
        return;
      }
      rethrow;
    }
  }

  /// Convenience: set only the status field for a task by id.
  static Future<void> setTaskStatus({
    required int id,
    required String status,
    String? forUserId,
  }) async {
    await updateTask(id: id, status: status, forUserId: forUserId);
  }

  static Future<void> markDone(int id, {String? forUserId}) =>
      setTaskStatus(id: id, status: 'done', forUserId: forUserId);
  static Future<void> markSkip(int id, {String? forUserId}) =>
      setTaskStatus(id: id, status: 'skip', forUserId: forUserId);
  static Future<void> markTodo(int id, {String? forUserId}) =>
      setTaskStatus(id: id, status: 'todo', forUserId: forUserId);

  /// Delete a task by id. Returns true if a row was deleted, false otherwise.
  static Future<bool> deleteTask(int id, {String? forUserId}) async {
    try {
      var del = _client.from('tasks').delete().eq('id', id);
      final uid = forUserId ?? _uid;
      if (uid != null) {
        del = del.eq('user_id', uid);
      }
      final List deletedList = await del.select('id');
      return deletedList.isNotEmpty;
    } catch (e) {
      final msg = e.toString().toLowerCase();
      if (msg.contains('permission denied') || msg.contains('policy')) {
        throw Exception(
          'Delete blocked by security policy. Please sign in as the owner of the task or adjust RLS policies.',
        );
      }
      rethrow;
    }
  }

  /// Mark past-due 'todo' tasks as 'skip' for the current user.
  /// This is a convenience clean-up to maintain accurate buckets.
  static Future<void> autoSkipPastDueTodos() async {
    final uid = _uid;
    if (uid == null) return;
    try {
      await _client
          .from('tasks')
          .update({'status': 'skip'})
          .lt('due_date', _toDateString(DateTime.now()))
          .eq('status', 'todo')
          .eq('user_id', uid);
    } catch (_) {
      // ignore silently; non-blocking hygiene step
    }
  }

  /// Compute the current daily streak for a user: number of consecutive days (starting from today)
  /// where the user completed at least one task. If today has no completed task, streak is 0 even
  /// if there were completions yesterday (resets at day end if missed).
  static Future<int> computeCurrentStreak({
    String? forUserId,
    int lookbackDays = 90,
  }) async {
    final uid = forUserId ?? _uid;
    if (uid == null) return 0;

    final today = DateTime.now();
    final since = today.subtract(Duration(days: lookbackDays));
    final sinceStr = _toDateString(since);

    // Fetch recent tasks with potential completion markers
    var q = _client
        .from('tasks')
        .select('due_date,status,is_done,done')
        .gte('due_date', sinceStr)
        .eq('user_id', uid);

    // Prefer server-side filter by completion when supported
    try {
      q = q.or('status.eq.done,is_done.eq.true,done.eq.true');
    } catch (_) {
      // Older SDKs may not support .or; we'll filter client-side
    }

    final List list = await q.limit(2000);

    // Build set of dates where there is at least one completed task
    final Set<String> completedDays = {};
    for (final row in list) {
      final status = (row['status'] ?? '').toString().toLowerCase();
      final isDoneRaw = row['is_done'] ?? row['done'];
      final isDone =
          status == 'done' ||
          (isDoneRaw is bool && isDoneRaw) ||
          (isDoneRaw is String && (isDoneRaw == 'true' || isDoneRaw == '1')) ||
          (isDoneRaw is num && isDoneRaw != 0);
      if (!isDone) continue;
      final due = row['due_date']?.toString();
      if (due != null && due.isNotEmpty) {
        completedDays.add(due);
      }
    }

    // Count consecutive days from today backwards
    int streak = 0;
    DateTime d = DateTime(today.year, today.month, today.day);
    while (true) {
      final key = _toDateString(d);
      if (!completedDays.contains(key)) break;
      streak++;
      d = d.subtract(const Duration(days: 1));
    }
    return streak;
  }

  /// Compute guardian streak: consecutive days up to today where at least
  /// one assisted linked to the guardian completed a task.
  static Future<int> computeGuardianStreak({
    String? guardianId,
    int lookbackDays = 90,
  }) async {
    final gid = guardianId ?? _uid;
    if (gid == null) return 0;
    final today = DateTime.now();
    final since = today.subtract(Duration(days: lookbackDays));
    final sinceStr = _toDateString(since);

    List assistedIds = [];
    try {
      final List rows = await _client
          .from('assisted_guardians')
          .select('assisted_id,status')
          .eq('guardian_id', gid);
      for (final r in rows) {
        final status = (r['status'] ?? 'accepted').toString();
        if (status == 'accepted' || status.isEmpty) {
          final aid = (r['assisted_id'] ?? '').toString();
          if (aid.isNotEmpty) assistedIds.add(aid);
        }
      }
    } catch (_) {
      return 0;
    }
    if (assistedIds.isEmpty) return 0;

    List list = [];
    try {
      list = await _client
          .from('tasks')
          .select('due_date,status,is_done,done,user_id')
          .inFilter('user_id', assistedIds)
          .gte('due_date', sinceStr)
          .limit(5000);
    } catch (_) {
      return 0;
    }

    final Set<String> completedDays = {};
    for (final row in list) {
      final status = (row['status'] ?? '').toString().toLowerCase();
      final isDoneRaw = row['is_done'] ?? row['done'];
      final isDone = status == 'done' ||
          (isDoneRaw is bool && isDoneRaw) ||
          (isDoneRaw is String && (isDoneRaw == 'true' || isDoneRaw == '1')) ||
          (isDoneRaw is num && isDoneRaw != 0);
      if (!isDone) continue;
      final due = row['due_date']?.toString();
      if (due != null && due.isNotEmpty) {
        completedDays.add(due);
      }
    }

    int streak = 0;
    DateTime d = DateTime(today.year, today.month, today.day);
    while (true) {
      final key = _toDateString(d);
      if (!completedDays.contains(key)) break;
      streak++;
      d = d.subtract(const Duration(days: 1));
    }
    return streak;
  }
}
