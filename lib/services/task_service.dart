import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Task service for interacting with Supabase `tasks` table.
///
/// Expected table schema (SQL suggestion):
///
/// create table if not exists public.tasks (
///   id bigint generated by default as identity primary key,
///   user_id uuid null references auth.users(id) on delete set null,
///   title text not null,
///   description text,
///   category text,
///   due_date date not null,
///   start_at timestamptz,
///   end_at timestamptz,
///   status text default 'todo',
///   created_at timestamptz not null default now()
/// );
class TaskService {
  TaskService._();

  static final SupabaseClient _client = Supabase.instance.client;
  static String? get _uid => _client.auth.currentUser?.id;

  static String _toDateString(DateTime date) => DateFormat('yyyy-MM-dd').format(date);

  static DateTime? _combineDateAndTime(DateTime date, TimeOfDay? tod) {
    if (tod == null) return null;
    return DateTime(date.year, date.month, date.day, tod.hour, tod.minute);
  }

/// Creates a task row in Supabase.
  static Future<void> createTask({
    required String title,
    String? description,
    required DateTime dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
    String? forUserId,
  }) async {
    final startAt = _combineDateAndTime(dueDate, startTime)?.toUtc();
    final endAt = _combineDateAndTime(dueDate, endTime)?.toUtc();

    final data = <String, dynamic>{
      'title': title,
      'description': description,
      'category': (category ?? '').trim().isEmpty ? null : category,
      'due_date': _toDateString(dueDate),
      'start_at': startAt?.toIso8601String(),
      'end_at': endAt?.toIso8601String(),
      'status': 'todo',
      'user_id': forUserId ?? _client.auth.currentUser?.id,
    }..removeWhere((key, value) => value == null);

    try {
      await _client.from('tasks').insert(data);
    } catch (e) {
      final msg = e.toString().toLowerCase();
      // Fallback if 'category' column doesn't exist in DB
      if (msg.contains("'category'") || (msg.contains('category') && data.containsKey('category'))) {
        final fallback = Map<String, dynamic>.from(data);
        fallback.remove('category');
        await _client.from('tasks').insert(fallback);
        return;
      }
      rethrow;
    }
  }

/// Fetch tasks for a specific calendar date (local date match on `due_date`).
  static Future<List<Map<String, dynamic>>> getTasksForDate(DateTime date, {String? forUserId}) async {
    final dateStr = _toDateString(date);
    var builder = _client
        .from('tasks')
        .select()
        .eq('due_date', dateStr);

    final uid = _uid;
    if (forUserId != null) {
      builder = builder.eq('user_id', forUserId);
    } else if (uid != null) {
      builder = builder.eq('user_id', uid);
    }

    final result = await builder.order('start_at', ascending: true);
    return List<Map<String, dynamic>>.from(result);
  }

/// Update an existing task.
  static Future<void> updateTask({
    required int id,
    String? title,
    String? description,
    DateTime? dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
    String? status,
    String? forUserId,
  }) async {
    final Map<String, dynamic> data = {};
    if (title != null) data['title'] = title;
    if (description != null) data['description'] = description;
    if (category != null) data['category'] = category.trim().isEmpty ? null : category;
    if (status != null) data['status'] = status;
    if (dueDate != null) data['due_date'] = _toDateString(dueDate);

    // We may need the existing due_date when only time changes
    DateTime? effectiveDate = dueDate;
    if (effectiveDate == null && (startTime != null || endTime != null)) {
      var builder = _client
          .from('tasks')
          .select('due_date')
          .eq('id', id);
      final uid2 = forUserId ?? _uid;
      if (uid2 != null) builder = builder.eq('user_id', uid2);
      final List existingList = await builder.limit(1);
      if (existingList.isNotEmpty) {
        final dueStr = existingList.first['due_date']?.toString();
        if (dueStr != null && dueStr.isNotEmpty) {
          try {
            effectiveDate = DateTime.parse(dueStr);
          } catch (_) {}
        }
      }
    }

    if (effectiveDate != null) {
      if (startTime != null) {
        final startAt = _combineDateAndTime(effectiveDate, startTime)?.toUtc();
        data['start_at'] = startAt?.toIso8601String();
      }
      if (endTime != null) {
        final endAt = _combineDateAndTime(effectiveDate, endTime)?.toUtc();
        data['end_at'] = endAt?.toIso8601String();
      }
    }

    // Remove nulls so we only update provided fields
    data.removeWhere((key, value) => value == null);

    if (data.isEmpty) return; // nothing to update

    try {
      var upd = _client.from('tasks').update(data).eq('id', id);
      final uid = forUserId ?? _uid;
      if (uid != null) {
        upd = upd.eq('user_id', uid);
      }
      final List updatedList = await upd.select('id');
      if (updatedList.isEmpty) {
        throw Exception('Task not updated. It may not exist or you may not have permission.');
      }
    } catch (e) {
      final msg = e.toString().toLowerCase();
      if (msg.contains("'category'") || (msg.contains('category') && data.containsKey('category'))) {
        final fallback = Map<String, dynamic>.from(data);
        fallback.remove('category');
        var upd = _client.from('tasks').update(fallback).eq('id', id);
        final uid = forUserId ?? _uid;
        if (uid != null) {
          upd = upd.eq('user_id', uid);
        }
        final List updatedList = await upd.select('id');
        if (updatedList.isEmpty) {
          throw Exception('Task not updated. It may not exist or you may not have permission.');
        }
        return;
      }
      rethrow;
    }
  }

  /// Convenience: set only the status field for a task by id.
  static Future<void> setTaskStatus({required int id, required String status, String? forUserId}) async {
    await updateTask(id: id, status: status, forUserId: forUserId);
  }

  static Future<void> markDone(int id, {String? forUserId}) => setTaskStatus(id: id, status: 'done', forUserId: forUserId);
  static Future<void> markSkip(int id, {String? forUserId}) => setTaskStatus(id: id, status: 'skip', forUserId: forUserId);
  static Future<void> markTodo(int id, {String? forUserId}) => setTaskStatus(id: id, status: 'todo', forUserId: forUserId);

/// Delete a task by id. Returns true if a row was deleted, false otherwise.
  static Future<bool> deleteTask(int id, {String? forUserId}) async {
    try {
      var del = _client.from('tasks').delete().eq('id', id);
      final uid = forUserId ?? _uid;
      if (uid != null) {
        del = del.eq('user_id', uid);
      }
      final List deletedList = await del.select('id');
      return deletedList.isNotEmpty;
    } catch (e) {
      final msg = e.toString().toLowerCase();
      if (msg.contains('permission denied') || msg.contains('policy')) {
        throw Exception('Delete blocked by security policy. Please sign in as the owner of the task or adjust RLS policies.');
      }
      rethrow;
    }
  }

  /// Mark past-due 'todo' tasks as 'skip' for the current user.
  /// This is a convenience clean-up to maintain accurate buckets.
  static Future<void> autoSkipPastDueTodos() async {
    final uid = _uid;
    if (uid == null) return;
    try {
      await _client
          .from('tasks')
          .update({'status': 'skip'})
          .lt('due_date', _toDateString(DateTime.now()))
          .eq('status', 'todo')
          .eq('user_id', uid);
    } catch (_) {
      // ignore silently; non-blocking hygiene step
    }
  }
}