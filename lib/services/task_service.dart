import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Task service for interacting with Supabase `tasks` table.
///
/// Expected table schema (SQL suggestion):
///
/// create table if not exists public.tasks (
///   id bigint generated by default as identity primary key,
///   user_id uuid null references auth.users(id) on delete set null,
///   title text not null,
///   description text,
///   category text,
///   due_date date not null,
///   start_at timestamptz,
///   end_at timestamptz,
///   status text default 'todo',
///   created_at timestamptz not null default now()
/// );
class TaskService {
  TaskService._();

  static final SupabaseClient _client = Supabase.instance.client;

  static String _toDateString(DateTime date) => DateFormat('yyyy-MM-dd').format(date);

  static DateTime? _combineDateAndTime(DateTime date, TimeOfDay? tod) {
    if (tod == null) return null;
    return DateTime(date.year, date.month, date.day, tod.hour, tod.minute);
  }

  /// Creates a task row in Supabase.
  static Future<void> createTask({
    required String title,
    String? description,
    required DateTime dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
  }) async {
    final startAt = _combineDateAndTime(dueDate, startTime)?.toUtc();
    final endAt = _combineDateAndTime(dueDate, endTime)?.toUtc();

    final data = <String, dynamic>{
      'title': title,
      'description': description,
      'category': (category ?? '').trim().isEmpty ? null : category,
      'due_date': _toDateString(dueDate),
      'start_at': startAt?.toIso8601String(),
      'end_at': endAt?.toIso8601String(),
      'status': 'todo',
      'user_id': _client.auth.currentUser?.id,
    }..removeWhere((key, value) => value == null);

    try {
      await _client.from('tasks').insert(data);
    } catch (e) {
      final msg = e.toString().toLowerCase();
      // Fallback if 'category' column doesn't exist in DB
      if (msg.contains("'category'") || msg.contains('category') && data.containsKey('category')) {
        final fallback = Map<String, dynamic>.from(data);
        fallback.remove('category');
        await _client.from('tasks').insert(fallback);
        return;
      }
      rethrow;
    }
  }

  /// Fetch tasks for a specific calendar date (local date match on `due_date`).
  static Future<List<Map<String, dynamic>>> getTasksForDate(DateTime date) async {
    final dateStr = _toDateString(date);
    final result = await _client
        .from('tasks')
        .select()
        .eq('due_date', dateStr)
        .order('start_at', ascending: true);
    return List<Map<String, dynamic>>.from(result);
  }

  /// Update an existing task.
  static Future<void> updateTask({
    required int id,
    String? title,
    String? description,
    DateTime? dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
    String? status,
  }) async {
    final Map<String, dynamic> data = {};
    if (title != null) data['title'] = title;
    if (description != null) data['description'] = description;
    if (category != null) data['category'] = category.trim().isEmpty ? null : category;
    if (status != null) data['status'] = status;
    if (dueDate != null) data['due_date'] = _toDateString(dueDate);

    // We may need the existing due_date when only time changes
    DateTime? effectiveDate = dueDate;
    if (effectiveDate == null && (startTime != null || endTime != null)) {
      final existingList = await _client
          .from('tasks')
          .select('due_date')
          .eq('id', id)
          .limit(1);
      if (existingList.isNotEmpty) {
        final dueStr = existingList.first['due_date']?.toString();
        if (dueStr != null && dueStr.isNotEmpty) {
          try { effectiveDate = DateTime.parse(dueStr); } catch (_) {}
        }
      }
    }

    if (effectiveDate != null) {
      if (startTime != null) {
        final startAt = _combineDateAndTime(effectiveDate, startTime)?.toUtc();
        data['start_at'] = startAt?.toIso8601String();
      }
      if (endTime != null) {
        final endAt = _combineDateAndTime(effectiveDate, endTime)?.toUtc();
        data['end_at'] = endAt?.toIso8601String();
      }
    }

    // Remove nulls so we only update provided fields
    data.removeWhere((key, value) => value == null);

    if (data.isEmpty) return; // nothing to update

    try {
      await _client.from('tasks').update(data).eq('id', id);
    } catch (e) {
      final msg = e.toString().toLowerCase();
      if (msg.contains("'category'") || (msg.contains('category') && data.containsKey('category'))) {
        final fallback = Map<String, dynamic>.from(data);
        fallback.remove('category');
        await _client.from('tasks').update(fallback).eq('id', id);
        return;
      }
      rethrow;
    }
  }

  /// Delete a task by id.
  static Future<bool> deleteTask(int id) async {
    try {
      // Ask PostgREST to return the deleted row; null means nothing deleted (likely RLS)
      final res = await _client
          .from('tasks')
          .delete()
          .eq('id', id)
          .select('id')
          .maybeSingle();
      return res != null;
    } on PostgrestException catch (e) {
      // Surface clearer message for common RLS/permission issues
      final msg = e.message.toLowerCase();
      if (msg.contains('permission denied') || msg.contains('policy')) {
        throw Exception('Delete blocked by security policy. Please sign in as the owner of the task or adjust RLS policies.');
      }
      rethrow;
    }
  }
}
