import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Task service for interacting with Supabase `tasks` table.
///
/// Expected table schema (SQL suggestion):
///
/// create table if not exists public.tasks (
///   id bigint generated by default as identity primary key,
///   user_id uuid null references auth.users(id) on delete set null,
///   title text not null,
///   description text,
///   category text,
///   due_date date not null,
///   start_at timestamptz,
///   end_at timestamptz,
///   status text default 'todo',
///   created_at timestamptz not null default now()
/// );
class TaskService {
  TaskService._();

  static final SupabaseClient _client = Supabase.instance.client;
  static String? get _uid => _client.auth.currentUser?.id;

  static String _toDateString(DateTime date) => DateFormat('yyyy-MM-dd').format(date);

  static DateTime? _combineDateAndTime(DateTime date, TimeOfDay? tod) {
    if (tod == null) return null;
    return DateTime(date.year, date.month, date.day, tod.hour, tod.minute);
  }

/// Creates a task row in Supabase.
  static Future<void> createTask({
    required String title,
    String? description,
    required DateTime dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
  }) async {
    final startAt = _combineDateAndTime(dueDate, startTime)?.toUtc();
    final endAt = _combineDateAndTime(dueDate, endTime)?.toUtc();

    final data = <String, dynamic>{
      'title': title,
      'description': description,
      'category': (category ?? '').trim().isEmpty ? null : category,
      'due_date': _toDateString(dueDate),
      'start_at': startAt?.toIso8601String(),
      'end_at': endAt?.toIso8601String(),
      'status': 'todo',
      'user_id': _client.auth.currentUser?.id,
    }..removeWhere((key, value) => value == null);

    try {
      await _client.from('tasks').insert(data);
    } catch (e) {
      final msg = e.toString().toLowerCase();
      // Fallback if 'category' column doesn't exist in DB
      if (msg.contains("'category'") || (msg.contains('category') && data.containsKey('category'))) {
        final fallback = Map<String, dynamic>.from(data);
        fallback.remove('category');
        await _client.from('tasks').insert(fallback);
        return;
      }
      rethrow;
    }
  }

/// Fetch tasks for a specific calendar date (local date match on `due_date`).
  static Future<List<Map<String, dynamic>>> getTasksForDate(DateTime date) async {
    final dateStr = _toDateString(date);
    var builder = _client
        .from('tasks')
        .select()
        .eq('due_date', dateStr);

    final uid = _uid;
    if (uid != null) {
      builder = builder.eq('user_id', uid);
    }

    final result = await builder.order('start_at', ascending: true);
    return List<Map<String, dynamic>>.from(result);
  }

/// Update an existing task.
  static Future<void> updateTask({
    required int id,
    String? title,
    String? description,
    DateTime? dueDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    String? category,
    String? status,
  }) async {
    final Map<String, dynamic> data = {};
    if (title != null) data['title'] = title;
    if (description != null) data['description'] = description;
    if (category != null) data['category'] = category.trim().isEmpty ? null : category;
    if (status != null) data['status'] = status;
    if (dueDate != null) data['due_date'] = _toDateString(dueDate);

    // We may need the existing due_date when only time changes
    DateTime? effectiveDate = dueDate;
    if (effectiveDate == null && (startTime != null || endTime != null)) {
      var builder = _client
          .from('tasks')
          .select('due_date')
          .eq('id', id);
      final uid2 = _uid;
      if (uid2 != null) builder = builder.eq('user_id', uid2);
      final List existingList = await builder.limit(1);
      if (existingList.isNotEmpty) {
        final dueStr = existingList.first['due_date']?.toString();
        if (dueStr != null && dueStr.isNotEmpty) {
          try {
            effectiveDate = DateTime.parse(dueStr);
          } catch (_) {}
        }
      }
    }

    if (effectiveDate != null) {
      if (startTime != null) {
        final startAt = _combineDateAndTime(effectiveDate, startTime)?.toUtc();
        data['start_at'] = startAt?.toIso8601String();
      }
      if (endTime != null) {
        final endAt = _combineDateAndTime(effectiveDate, endTime)?.toUtc();
        data['end_at'] = endAt?.toIso8601String();
      }
    }

    // Remove nulls so we only update provided fields
    data.removeWhere((key, value) => value == null);

    if (data.isEmpty) return; // nothing to update

    try {
      var upd = _client.from('tasks').update(data).eq('id', id);
      final uid = _uid;
      if (uid != null) {
        upd = upd.eq('user_id', uid);
      }
      final List updatedList = await upd.select('id');
      if (updatedList.isEmpty) {
        throw Exception('Task not updated. It may not exist or you may not have permission.');
      }
    } catch (e) {
      final msg = e.toString().toLowerCase();
      if (msg.contains("'category'") || (msg.contains('category') && data.containsKey('category'))) {
        final fallback = Map<String, dynamic>.from(data);
        fallback.remove('category');
        var upd = _client.from('tasks').update(fallback).eq('id', id);
        final uid = _uid;
        if (uid != null) {
          upd = upd.eq('user_id', uid);
        }
        final List updatedList = await upd.select('id');
        if (updatedList.isEmpty) {
          throw Exception('Task not updated. It may not exist or you may not have permission.');
        }
        return;
      }
      rethrow;
    }
  }

/// Delete a task by id.
  static Future<void> deleteTask(int id) async {
    var del = _client.from('tasks').delete().eq('id', id);
    final uid = _uid;
    if (uid != null) {
      del = del.eq('user_id', uid);
    }
    final List deletedList = await del.select('id');
    if (deletedList.isEmpty) {
      throw Exception('Task not deleted. It may not exist or you may not have permission.');
    }
  }
}